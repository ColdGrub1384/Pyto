# -*- coding: utf-8 -*-
"""
Some Pyto core functions
"""

import os

from pyto import *
from pyto import __isMainApp__
import os
import sys
import traceback
import threading
import time

if "widget" not in os.environ:
    from code import interact, InteractiveConsole
    import importlib.util
    from importlib import reload
    import builtins
    import pdb
    from colorama import Fore, Back, Style

    try:
        from rubicon.objc import *
    except ValueError:

        def ObjCClass(class_name):
            return None

    try:
        import pyto_core as pc
    except ImportError:
        pass


def excepthook(exc, value, tb, limit=None):
    message = traceback.format_exception(exc, value, tb, limit=limit)

    if limit is None:
        del message[1] # Remove the first element of the traceback in the REPL

    for part in message:
        if part == message[0]: # Traceback (most recent blah blah blah)
            msg = Fore.RED + part + Style.RESET_ALL
        elif part == message[-1]: #Â Exception: message
            parts = part.split(":")
            parts[0] = Fore.RED + parts[0] + Style.RESET_ALL
            
            msg = ":".join(parts)
        elif part.startswith("  File"): # File "file", line 1, in function
            parts = part.split("\"")
            parts[1] = Fore.YELLOW + parts[1] + Style.RESET_ALL
            
            parts = "\"".join(parts).split("\n")
            first_line = parts[0].split(" ")
            first_line[-1] = Fore.YELLOW + first_line[-1] + Style.RESET_ALL
            parts[0] = " ".join(first_line)
            msg = "\n".join(parts)
        else:
            msg = part
        
        builtins.print(msg, file=sys.stderr, end="")


__repl_namespace__ = {}

def __runREPL__(repl_name=""):

    if "widget" in os.environ:
        return
    
    __namespace__ =  {"clear":ClearREPL()}
    __repl_namespace__[repl_name] = __namespace__
    
    def read(prompt):
        import console
        console.__repl_namespace__[repl_name] = __namespace__

        return InteractiveConsole().raw_input(prompt=prompt)

    sys.argv = [""]

    Python.shared.isScriptRunning = True

    if banner is None:
        banner = f"Python {sys.version}\n{str(__Class__('MenuTableViewController').pytoVersion)}\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\nType \"clear()\" to clear the console."
    interact(readfunc=read, local=__namespace__, banner=banner)


# MARK: - Running


def __clear_mods__():
    try:
        del sys.modules["pip"]
    except KeyError:
        pass

    try:
        del sys.modules["pdb"]
    except KeyError:
        pass

    try:
        del sys.modules["logging"]
        del sys.modules["logging.config"]
        del sys.modules["logging.handlers"]
    except KeyError:
        pass

    try:
        del sys.modules["pyto_ui"]
    except KeyError:
        pass

    try:
        del sys.modules["turtle"]
    except KeyError:
        pass

    try:
        _values = sys.modules["_values"]
        
        for attr in dir(_values):
            if attr not in _values._dir:
                delattr(_values, attr)
            
    except:
        pass

    try:
        if "matplotlib" in sys.modules:
            import matplotlib.pyplot as plt

            plt.close()
            plt.clf()
    except:
        pass

    keys = list(sys.modules.keys())
    for key in keys:
        try:
            mod = sys.modules[key]
            if os.access(mod.__file__, os.W_OK) and not mod.__file__.contains(os.path.expanduser("~/Library/python38")):
                del sys.modules[key]
        except AttributeError:
            pass
        except TypeError:
            pass


if "widget" not in os.environ:

    __script__ = None

    __is_loop_running__ = False

    __i__ = 0

    __breakpoints__ = []

    __are_breakpoints_set__ = True

    def run_script(path, replMode=False, debug=False, breakpoints=[]):
        """
        Run the script at given path catching exceptions.
    
        This function should only be used internally by Pyto.
    
        Args:
            path: The path of the script.
            replMode: If set to `True`, errors will not be handled.
            debug: Set to `True` for debugging.
            breakpoints: Lines to break if debugging.
        """

        __clear_mods__()

        python = Python.shared
        python.addScriptToList(path)

        currentDir = ""
        try:
            currentDir = str(python.currentWorkingDirectory)
        except:
            currentDir = os.path.expanduser(os.path.dirname(path))

        os.environ = {}
        for (key, value) in python.environment.items():
            os.environ[str(key)] = str(value)

        sys.argv = [path]
        for arg in python.args:
            if arg != "":
                sys.argv.append(str(arg))

        d = os.path.expanduser("~/tmp")
        filesToRemove = []
        try:
            filesToRemove = [os.path.join(d, f) for f in os.listdir(d)]
        except:
            pass

        try:
            filesToRemove.remove(d + "/Temporary.py")
        except:
            pass

        try:
            filesToRemove.remove(d + "/Watch.py")
        except:
            pass

        for f in filesToRemove:

            if f.endswith(".repl.py"):
                continue

            try:
                os.remove(f)
            except PermissionError:
                pass

        def run():

            pip_directory = os.path.expanduser("~/Documents/site-packages")
            Python.shared.isScriptRunning = True
            os.chdir(currentDir)
            try:
                sys.path.remove(pip_directory)
            except:
                pass
            sys.path.insert(-1, currentDir)
            sys.path.insert(-1, pip_directory)

            try:
                global __script__
                spec = importlib.util.spec_from_file_location("__main__", path)
                __script__ = importlib.util.module_from_spec(spec)
                sys.modules["__main__"] = __script__
                if debug and "widget" not in os.environ:

                    try:
                        console
                    except:
                        import console

                    console.__are_breakpoints_set__ = False
                    console.__breakpoints__ = breakpoints

                    console.__i__ = -1

                    old_input = input

                    def debugger_input(prompt):

                        try:
                            console
                        except:
                            import console

                        if not console.__are_breakpoints_set__:

                            breakpoints = console.__breakpoints__
                            console.__i__ += 1

                            if len(breakpoints) < console.__i__:
                                console.__are_breakpoints_set__ = True
                                return ""

                            try:
                                breakpoints[console.__i__ + 1]
                            except:
                                console.__are_breakpoints_set__ = True

                            return "b " + str(breakpoints[console.__i__])
                        else:
                            console.__should_inspect__ = True
                            return old_input(prompt)

                    if len(breakpoints) > 0:
                        builtins.input = debugger_input

                    pdb.main(["pdb", path])
                    builtins.input = old_input
                else:
                    spec.loader.exec_module(__script__)
                    return (path, vars(__script__), None)
            except SystemExit:
                if PyCallbackHelper is not None:
                    PyCallbackHelper.cancelled = True
                
                return (path, vars(__script__), SystemExit)
            except KeyboardInterrupt:
                if PyCallbackHelper is not None:
                    PyCallbackHelper.cancelled = True
                
                return (path, vars(__script__), KeyboardInterrupt)
            except Exception as e:

                if PyCallbackHelper is not None:
                    PyCallbackHelper.exception = str(e)

                if not __isMainApp__() or replMode:
                    print(traceback.format_exc())
                    if not replMode:
                        Python.shared.fatalError(traceback.format_exc())
                else:
                    exc_type, exc_obj, exc_tb = sys.exc_info()

                    extracts = traceback.extract_tb(exc_tb)
                    count = len(extracts)

                    lineNumber = -1

                    fileName = path
                    for i, extract in enumerate(extracts):
                        if extract[0] == fileName:
                            lineNumber = extract[1]
                            break
                        count -= 1

                    if (
                        type(e) == SyntaxError
                    ):  # The last word in a `SyntaxError` exception is the line number
                        lineNumber = [
                            int(s) for s in (str(e)[:-1]).split() if s.isdigit()
                        ][-1]

                    Python.shared.errorType = exc_type.__name__
                    Python.shared.errorReason = str(e)
                    for console in ConsoleViewController.objcVisibles:
                        if (
                            console.editorSplitViewController.editor.document.fileURL.path
                            != path
                        ):
                            continue
                        console.editorSplitViewController.editor.showErrorAtLine(
                            lineNumber
                        )

                    excepthook(exc_type, exc_obj, exc_tb, -count)

                    try:
                        PyOutputHelper.printError(
                            "", script=threading.current_thread().script_path
                        )
                    except AttributeError:
                        PyOutputHelper.printError("", script=None)

                    if "cv2.error" in traceback.format_exc(limit=-count) and "!_src.empty()" in error:
                        string = "\nOn Pyto, 'cv2.VideoCapture.read' may return an invalid value the first time. If you are running a loop for capturing a video from the camera, check if the return value is valid before using it. See the 'OpenCV/face_detection.py' example.\n"
                        try:
                            PyOutputHelper.printError(
                                string, script=threading.current_thread().script_path
                            )
                        except AttributeError:
                            PyOutputHelper.printError(string, script=None)

                    sys.path.remove(currentDir)

                    if debug:
                        pdb.post_mortem(exc_tb)

                    return (path, vars(__script__), e)

            if __isMainApp__():

                EditorViewController.runningLine = 0

                ConsoleViewController.enableDoneButton()

                ReviewHelper.shared.launches = ReviewHelper.shared.launches + 1
                ReviewHelper.shared.requestReview()

        Python.shared.isScriptRunning = True
        Python.shared._isScriptRunning = True

        if "__editor_delegate__" in dir(builtins) and builtins.__editor_delegate__ is not None:
            delegate = builtins.__editor_delegate__

            def _run():
                import builtins
                delegate = builtins.__editor_delegate__

                t = run()
                if type(t) is tuple and len(t) == 3:
                    try:
                        delegate.did_run_script(t[0], t[1], t[2])
                    except NotImplementedError:
                        pass
                    except SystemExit:
                        pass
                    except KeyboardInterrupt:
                        pass
                    except Exception as e:
                        traceback.print_tb()

            try:
                delegate.run_script(path, _run)
            except NotImplementedError:
                _run()
        else:
            run()

        Python.shared._isScriptRunning = False
        Python.shared.isScriptRunning = False
        Python.shared.removeScriptFromList(path)

        sys.path = list(dict.fromkeys(sys.path))

        time.sleep(0.2)


# MARK: - I/O

ignoredThreads = []
"""
All output and input request from these threads will be ignored.
"""

class ClearREPL():

    def __repr__(self):
        return self.__str__()

    def __str__(self):
        return "Type 'clear()' to clear the console."
        
    def __call__(self):
        clear()

def clear():
    """
    Clears the console.
    """

    if threading.current_thread() in ignoredThreads:
        return

    try:
        ConsoleViewController.clearConsoleForPath(
            threading.current_thread().script_path
        )
    except AttributeError:
        try:
            ConsoleViewController.clearConsoleForPath(None)
        except:
            ConsoleViewController.visible.clear()

    time.sleep(0.1)


__PyInputHelper__ = PyInputHelper


def input(prompt: str = None):
    """
    Requests input with given prompt.

    :param prompt: Text printed before the user's input without a newline.
    """

    if "widget" in os.environ:
        return None

    if prompt is None:
        prompt = ""

    print(prompt, end="")

    try:
        path = threading.current_thread().script_path
    except AttributeError:
        path = ""

    __PyInputHelper__.userInput.removeObjectForKey(path)

    time.sleep(0.2)

    try:
        __PyInputHelper__.showAlertWithPrompt(
            prompt, script=threading.current_thread().script_path
        )
    except AttributeError:
        __PyInputHelper__.showAlertWithPrompt(prompt, script=None)

    while (
        __PyInputHelper__.getUserInput(path) is None
        or threading.currentThread() in ignoredThreads
    ):
        time.sleep(0.2)

    userInput = __PyInputHelper__.getUserInput(path)

    __PyInputHelper__.userInput.removeObjectForKey(path)

    time.sleep(0.2)

    return str(userInput)


def print(*objects, sep: str = None, end: str = None):
    """
    Prints to the Pyto console, not to the stdout. Works as the builtin `print` function but does not support printing to a custom file. Pyto catches by default the stdout and the stderr, so use the builtin function instead. This function is mainly for internal use.
    """

    if sep is None:
        sep = " "
    if end is None:
        end = "\n"
    array = map(str, objects)

    printed = sep.join(array) + end
    try:
        if objects[0].__class__ is str:
            printed = objects[0]
    except:
        pass

    try:
        PyOutputHelper.print(printed, script=threading.current_thread().script_path)
    except AttributeError:
        PyOutputHelper.print(printed, script=None)


# MARK: - Alerts

if "widget" not in os.environ:

    PyAlert = PyAlert
    """
    A class representing an alert.

    Example:

    code-block::
        python

        alert = console.Alert.alertWithTitle("Hello", message="Hello World!")
        alert.addAction("Ok")
        alert.addCancelAction("Cancel")
        if (alert.show() == "Ok"):
            print("Good Bye!")
    """

    class Alert:
        """
        A wrapper of ``UIAlert``.
        """

        pyAlert = None

        def __init__(self):
            self.pyAlert = PyAlert.alloc().init()

        @staticmethod
        def alertWithTitle(title: str, message: str) -> "Alert":
            """
            Creates an alert.
            
            :param title: The title of the alert.
            :param message: The message of the alert.
            """

            alert = Alert()
            alert.pyAlert.title = title
            alert.pyAlert.message = message
            return alert

        __actions__ = []

        def addAction(self, title: str):
            """
            Add an action with given title.

            :param title: The title of the action.
            """

            self.pyAlert.addAction(title)

        def addDestructiveAction(self, title: str):
            """
            Add a destructive action with given title.
            
            :param title: The title of the action.
            """

            self.pyAlert.addDestructiveAction(title)

        def addCancelAction(self, title: str):
            """
            Add a cancel action with given title. Can only added once.

            :param title: The title of the action.
            """

            if not self.pyAlert.addCancelAction(title):
                raise ValueError("There is already a cancel action.")

        def show(self) -> str:
            """
            Shows alert.

            Returns the title of the selected action.

            :rtype: str
            """

            path = None
            try:
                path = threading.current_thread().script_path
            except AttributeError:
                pass

            return self.pyAlert._show(path)


else:
    PyAlert = None
    Alert = None

__all__ = ["Alert", "clear", "print", "input"]
