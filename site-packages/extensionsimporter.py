"""
Module used internally by Pyto for importing C extension.
"""

import sys
import importlib
import traceback
import os
import warnings
import ctypes
from pyto import Python

c = ctypes.CDLL(None)

def update_mods():
    # Builtins
    def add(mod):
        if str(mod) in sys.builtin_module_names:
            return
        
        sys.builtin_module_names += (str(mod),)
        Python.shared.importedModules.addObject(mod)

    try:
        for mod in Python.shared.modules:
            add(mod)
    except TypeError:
        for mod in Python.shared.modules():
            add(mod)


if "widget" not in os.environ:
    from sharing import open_url
    import urllib.parse
    
    try:
        import httplib
    except:
        import http.client as httplib

    def have_internet():
        conn = httplib.HTTPConnection("www.google.com", timeout=5)
        try:
            conn.request("HEAD", "/")
            conn.close()
            return True
        except:
            conn.close()
            return False

def report_error(module, trace_back, e):
    """
    Sends an E-mail reporting error.
    
    Args:
        module: The module's that cannot be imported name.
        trace_back: Traceback as string.
    """

    if type(e) is ModuleNotFoundError:
        return

    try:
        from pyto_ui import Alert
        alert = Alert(title=module, message="An error occurred while importing "+module+".\n\nDo you want to report error to the developer?")
        alert.add_action("Report")
        alert.add_cancel_action("Cancel")

        if alert.show() == "Report":
            open_url("mailto:adrian@labbe.me?subject="+module+"%20Importing%20Error&body="+urllib.parse.quote(trace_back))
    except ImportError:
        pass

# MARK: - NumPy

class NumpyImporter(object):
    """
    Meta path for importing NumPy to be added to `sys.meta_path`.
    """
    
    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        if fullname in ('numpy.random._bit_generator', 'numpy.random._bounded_integers', 'numpy.random._common', 'numpy.random._generator', 'numpy.random._mt19937', 'numpy.core._multiarray_tests', 'numpy.core._operand_flag_tests', 'numpy.random._pcg64', 'numpy.random._philox', 'numpy.fft._pocketfft_internal', 'numpy.core._rational_tests', 'numpy.random._sfc64', 'numpy.core._struct_ufunc_tests', 'numpy.linalg._umath_linalg', 'numpy.core._umath_tests', 'numpy.linalg.lapack_lite', 'numpy.random.mtrand', 'numpy.core._multiarray_umath'):
            return self
        
        if fullname == 'numpy' and not self.__is_importing__:
            return self
        
        return
    
    def load_module(self, fullname):
        f = fullname
        if f != 'numpy':
            f = '__' + fullname.replace('.', '_')
        mod = sys.modules.get(f)
        if mod is None:
            def importMod():
                with warnings.catch_warnings(record=True) as w:
                    mod = importlib.__import__(f)
                    sys.modules[fullname] = mod
            
            if fullname != 'numpy' or "widget" in os.environ:
                importMod()
            else:
                try:
                    self.__is_importing__ = True
                    importMod()
                    self.__is_importing__ = False
                except KeyboardInterrupt:
                    pass
                except SystemExit:
                    pass
                except Exception as e:
                    
                    report_error('Numpy', traceback.format_exc(), e)
                    raise
                finally:
                    self.__is_importing__ = False

            return mod
        
        return mod

# MARK: - Matplotlib

class MatplotlibImporter(object):
    """
    Meta path for importing Matplotlib to be added to `sys.meta_path`.
    """
    
    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        if fullname in ('matplotlib.backends._backend_agg', 'matplotlib._path', 'matplotlib._image', 'matplotlib._png', 'matplotlib.ft2font', 'matplotlib._contour', 'matplotlib._qhull', 'matplotlib._tri', 'matplotlib.ttconv'):
            return self
        
        if fullname == 'matplotlib' and not self.__is_importing__:
            return self
        
        return
    
    def load_module(self, fullname):
    
        c.init_matplotlib()
        update_mods()
    
        f = fullname
        if f != 'matplotlib':
            f = '__' + fullname.replace('.', '_')
        mod = sys.modules.get(f)
        if mod is None:
            def importMod():
                with warnings.catch_warnings(record=True) as w:
                    mod = importlib.__import__(f)
                    sys.modules[fullname] = mod
            
            if fullname != 'matplotlib' or "widget" in os.environ:
                importMod()
            else:
                try:
                    self.__is_importing__ = True
                    importMod()
                    self.__is_importing__ = False
                except KeyboardInterrupt:
                    return
                except SystemExit:
                    return
                except Exception as e:
                    
                    report_error('Matplotlib', traceback.format_exc(), e)
                    raise
                finally:
                    self.__is_importing__ = False
            
            return mod
        
        return mod

# MARK: - Pandas

class PandasImporter(object):
    """
    Meta path for importing Pandas to be added to `sys.meta_path`.
    """
    
    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        
        if fullname == 'pandas' and not self.__is_importing__:
            return self
        
        if fullname in ('pandas.io.sas._sas', 'pandas._libs.window.aggregations', 'pandas._libs.algos', 'pandas._libs.tslibs.c_timestamp', 'pandas._libs.tslibs.ccalendar', 'pandas._libs.tslibs.conversion', 'pandas._libs.tslibs.fields', 'pandas._libs.tslibs.frequencies', 'pandas._libs.groupby', 'pandas._libs.hashing', 'pandas._libs.hashtable', 'pandas._libs.index', 'pandas._libs.window.indexers', 'pandas._libs.indexing', 'pandas._libs.internals', 'pandas._libs.interval', 'pandas._libs.join', 'pandas._libs.json', 'pandas._libs.lib', 'pandas._libs.missing', 'pandas._libs.tslibs.nattype', 'pandas._libs.tslibs.np_datetime', 'pandas._libs.tslibs.offsets', 'pandas._libs.ops_dispatch', 'pandas._libs.ops', 'pandas._libs.parsers', 'pandas._libs.tslibs.parsing', 'pandas._libs.tslibs.period', 'pandas._libs.properties', 'pandas._libs.reduction', 'pandas._libs.reshape', 'pandas._libs.tslibs.resolution', 'pandas._libs.sparse', 'pandas._libs.tslibs.strptime', 'pandas._libs.testing', 'pandas._libs.tslibs.timedeltas', 'pandas._libs.tslibs.timestamps', 'pandas._libs.tslibs.timezones', 'pandas._libs.tslib', 'pandas._libs.tslibs.tzconversion', 'pandas._libs.writers'):
            return self
        
        return
    
    def load_module(self, fullname):
    
        c.init_pandas()
        update_mods()
    
        f = fullname
        if f != 'pandas':
            f = '__' + fullname.replace('.', '_')
        mod = sys.modules.get(f)
        if mod is None:
            def importMod():
                with warnings.catch_warnings(record=True) as w:
                    mod = importlib.__import__(f)
                    sys.modules[fullname] = mod
            
            if fullname != 'pandas' or "widget" in os.environ:
                importMod()
            else:
                try:
                    self.__is_importing__ = True
                    importMod()
                    self.__is_importing__ = False
                except KeyboardInterrupt:
                    return
                except SystemExit:
                    return
                except Exception as e:
                    
                    report_error('Pandas', traceback.format_exc(), e)
                    raise
                finally:
                    self.__is_importing__ = False
            
            return mod
        
        return mod

# MARK: - Pillow

class PillowImporter(object):
    """
    Meta path for importing Pillow to be added to `sys.meta_path`.
    """
    
    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        if fullname in ('PIL._imaging', 'PIL._imagingft', 'PIL._imagingmath', 'PIL._imagingmorph', 'PIL._imagingtk'):
            return self
        
        if fullname == 'PIL' and not self.__is_importing__:
            return self
        
        return
    
    def load_module(self, fullname):
        
        c.init_pil()
        update_mods()
    
        f = fullname
        if f != 'PIL':
            f = '__' + fullname.replace('.', '_')
        mod = sys.modules.get(f)
        if mod is None:
            def importMod():
                with warnings.catch_warnings(record=True) as w:
                    mod = importlib.__import__(f)
                    sys.modules[fullname] = mod
            
            if fullname != 'PIL':
                importMod()
            else:
                try:
                    self.__is_importing__ = True
                    importMod()
                    self.__is_importing__ = False
                except KeyboardInterrupt:
                    pass
                except SystemExit:
                    pass
                except Exception as e:
                    
                    report_error('Pillow', traceback.format_exc(), e)
                    raise
                finally:
                    self.__is_importing__ = False

            return mod
        
        return mod

# MARK: - Biopython

class BiopythonImporter(object):
    """
    Meta path for importing Biopython to be added to `sys.meta_path`.
    """
    
    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        if fullname in ('Bio.Align._aligners', 'Bio.KDTree._CKDTree', 'Bio.Cluster._cluster', 'Bio.motifs._pwm', 'Bio.Nexus.cnexus', 'Bio.cpairwise2', 'Bio.PDB.kdtrees', 'Bio.PDB.QCPSuperimposer.qcprotmodule', 'Bio.trie'):
            return self
        
        if fullname == 'Bio' and not self.__is_importing__:
            return self
        
        return
    
    def load_module(self, fullname):
    
        c.init_biopython()
        update_mods()
    
        f = fullname
        if f != 'Bio':
            f = '__' + fullname.replace('.', '_')
        mod = sys.modules.get(f)
        if mod is None:
            def importMod():
                with warnings.catch_warnings(record=True) as w:
                    mod = importlib.__import__(f)
                    sys.modules[fullname] = mod
            
            if fullname != 'Bio' or "widget" in os.environ:
                importMod()
            else:
                try:
                    self.__is_importing__ = True
                    importMod()
                    self.__is_importing__ = False
                except KeyboardInterrupt:
                    pass
                except SystemExit:
                    pass
                except Exception as e:
                    
                    report_error('Biopython', traceback.format_exc(), e)
                    raise
                finally:
                    self.__is_importing__ = False

            return mod
        
        return mod

# MARK: - LXML

class LXMLImporter(object):
    """
    Meta path for importing LXML to be added to `sys.meta_path`.
    """
    
    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        
        if fullname == 'lxml' and not self.__is_importing__:
            return self
                
        if fullname in ('lxml._elementpath', 'lxml.builder', 'lxml.etree', 'lxml.html.clean', 'lxml.html.diff', 'lxml.objectifiy', 'lxml.sax'):
            return self
        
        return
    
    def load_module(self, fullname):
    
        c.init_lxml()
        update_mods()
    
        f = fullname
        if f != 'lxml':
            f = '__' + fullname.replace('.', '_')
        mod = sys.modules.get(f)
        if mod is None:
            def importMod():
                with warnings.catch_warnings(record=True) as w:
                    mod = None
                    try:
                        mod = importlib.__import__(f)
                    except ImportError:
                        sys.builtin_module_names += (f,)
                        mod = importlib.__import__(f)
                    
                    sys.modules[fullname] = mod
            
            if fullname != 'lxml' or "widget" in os.environ:
                importMod()
            else:
                try:
                    self.__is_importing__ = True
                    importMod()
                    self.__is_importing__ = False
                except KeyboardInterrupt:
                    return
                except SystemExit:
                    return
                except Exception as e:
                    
                    report_error('LXML', traceback.format_exc(), e)
                    raise
                finally:
                    self.__is_importing__ = False
            
            return mod
        
        return mod

# MARK: - SciPy

# Thanks to @goodclass for the amazing work!!!!!!

class ScipyImporter(object):
    """
    Meta path for importing Scipy to be added to `sys.meta_path`.
    """

    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        if fullname in ('scipy.odr.__odrpack', 'scipy.cluster._optimal_leaf_ordering', 'scipy.cluster._vq', 'scipy.cluster._hierarchy', 'scipy.ndimage._ni_label', 'scipy.ndimage._nd_image', 'scipy.ndimage._ctest_oldapi', 'scipy.ndimage._cytest', 'scipy.ndimage._ctest', 'scipy.linalg._solve_toeplitz', 'scipy.linalg._flinalg', 'scipy.linalg._decomp_update', 'scipy.linalg._interpolative', 'scipy.linalg.cython_blas', 'scipy.linalg._flapack', 'scipy.linalg._fblas', 'scipy.linalg.cython_lapack', 'scipy.optimize._zeros', 'scipy.optimize._minpack', 'scipy.optimize._trlib._trlib', 'scipy.optimize._slsqp', 'scipy.optimize._group_columns', 'scipy.optimize._cobyla', 'scipy.optimize._lsq.givens_elimination', 'scipy.optimize.minpack2', 'scipy.optimize._lbfgsb', 'scipy.optimize._nnls', 'scipy.optimize.moduleTNC', 'scipy.integrate._odepack', 'scipy.integrate._test_multivariate', 'scipy.integrate._test_odeint_banded', 'scipy.integrate.lsoda', 'scipy.integrate.vode', 'scipy.integrate._quadpack', 'scipy.integrate._dop', 'scipy.io.matlab.streams', 'scipy.io.matlab.mio5_utils', 'scipy.io.matlab.mio_utils', 'scipy.io._test_fortran', 'scipy._lib._fpumode', 'scipy._lib._ccallback_c', 'scipy._lib.messagestream', 'scipy._lib._test_ccallback', 'scipy.special._comb', 'scipy.special.cython_special', 'scipy.special._ufuncs', 'scipy.special._test_round', 'scipy.special.specfun', 'scipy.special._ufuncs_cxx', 'scipy.special._ellip_harm_2', 'scipy.fftpack._fftpack', 'scipy.fftpack.convolve', 'scipy.interpolate.dfitpack', 'scipy.interpolate._bspl', 'scipy.interpolate._ppoly', 'scipy.interpolate.interpnd', 'scipy.interpolate._fitpack', 'scipy.interpolate._interpolate', 'scipy.sparse.linalg.isolve._iterative', 'scipy.sparse.linalg.eigen.arpack._arpack', 'scipy.sparse.linalg.dsolve._superlu', 'scipy.sparse._sparsetools', 'scipy.sparse.csgraph._reordering', 'scipy.sparse.csgraph._min_spanning_tree', 'scipy.sparse.csgraph._tools', 'scipy.sparse.csgraph._traversal', 'scipy.sparse.csgraph._shortest_path', 'scipy.sparse._csparsetools', 'scipy.spatial.qhull', 'scipy.spatial._voronoi', 'scipy.spatial._hausdorff', 'scipy.spatial.ckdtree', 'scipy.spatial._distance_wrap', 'scipy.signal._upfirdn_apply', 'scipy.signal.sigtools', 'scipy.signal._peak_finding_utils', 'scipy.signal._spectral', 'scipy.signal.spline', 'scipy.signal._max_len_seq_inner', 'scipy.stats.statlib', 'scipy.stats.mvn', 'scipy.stats._stats'):
            return self
        
        if fullname == 'scipy' and not self.__is_importing__:
            return self
        return
    
    def load_module(self, fullname):
    
        c.init_scipy()
        update_mods()
    
        f = fullname
        if f != 'scipy':
            f = '__' + fullname.replace('.', '_')
        mod = sys.modules.get(f)
        
        if mod is None:
            def importMod():
                with warnings.catch_warnings(record=True) as w:
                    mod = None
                    try:
                        mod = importlib.__import__(f)
                    except ImportError:
                        sys.builtin_module_names += (f,)
                        mod = importlib.__import__(f)
                    
                    sys.modules[fullname] = mod
            
            if fullname != 'scipy' or "widget" in os.environ:
                importMod()
            else:
                try:
                    self.__is_importing__ = True
                    importMod()
                    self.__is_importing__ = False
                except KeyboardInterrupt:
                    pass
                except SystemExit:
                    pass
                except Exception as e:
                    
                    report_error('scipy', traceback.format_exc(), e)
                    raise
                finally:
                    self.__is_importing__ = False
            
            return mod
        return mod

# MARK: - SkLearn

class SkLearnImporter(object):
    """
    Meta path for importing SkLearn to be added to `sys.meta_path`.
    """
    
    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        if fullname in ('sklearn.neighbors._ball_tree', 'sklearn.manifold._barnes_hut_tsne', 'sklearn.ensemble._hist_gradient_boosting._binning', 'sklearn.linear_model._cd_fast', 'sklearn.decomposition._cdnmf_fast', 'sklearn.__check_build._check_build', 'sklearn.tree._criterion', 'sklearn.preprocessing._csr_polynomial_expansion', 'sklearn.utils._cython_blas', 'sklearn.cluster._dbscan_inner', 'sklearn.neighbors._dist_metrics', 'sklearn.metrics.cluster._expected_mutual_info_fast', 'sklearn.utils._fast_dict', 'sklearn.ensemble._hist_gradient_boosting._gradient_boosting', 'sklearn.ensemble._gradient_boosting', 'sklearn.feature_extraction._hashing_fast', 'sklearn.cluster._hierarchical_fast', 'sklearn._isotonic', 'sklearn.cluster._k_means_elkan', 'sklearn.cluster._k_means_fast', 'sklearn.neighbors._kd_tree', 'sklearn.svm._liblinear', 'sklearn.svm._libsvm_sparse', 'sklearn.svm._libsvm', 'sklearn.utils._logistic_sigmoid', 'sklearn.ensemble._hist_gradient_boosting._loss', 'sklearn.decomposition._online_lda_fast', 'sklearn.utils._openmp_helpers', 'sklearn.metrics._pairwise_fast', 'sklearn.ensemble._hist_gradient_boosting._predictor', 'sklearn.neighbors._quad_tree', 'sklearn.utils._random', 'sklearn.linear_model._sag_fast', 'sklearn.utils._seq_dataset', 'sklearn.linear_model._sgd_fast', 'sklearn.tree._splitter', 'sklearn.datasets._svmlight_format_fast', 'sklearn.tree._tree', 'sklearn.neighbors._typedefs', 'sklearn.tree._utils', 'sklearn.manifold._utils', 'sklearn.utils._weight_vector', 'sklearn.utils.arrayfuncs', 'sklearn.ensemble._hist_gradient_boosting.common', 'sklearn.utils.graph_shortest_path', 'sklearn.ensemble._hist_gradient_boosting.histogram', 'sklearn.utils.murmurhash', 'sklearn.utils.sparsefuncs_fast', 'sklearn.ensemble._hist_gradient_boosting.splitting', 'sklearn.ensemble._hist_gradient_boosting.utils'):
            return self
        
        if fullname == 'sklearn' and not self.__is_importing__:
            return self
        
        return
    
    def load_module(self, fullname):
    
        c.init_sklearn()
        update_mods()
    
        f = fullname
        if f != 'sklearn':
            f = '__' + fullname.replace('.', '_')
        mod = sys.modules.get(f)
        
        if mod is None:
            def importMod():
                with warnings.catch_warnings(record=True) as w:
                    mod = importlib.__import__(f)
                    sys.modules[fullname] = mod
            
            if fullname != 'sklearn' or "widget" in os.environ:
                importMod()
            else:
                try:
                    self.__is_importing__ = True
                    importMod()
                    self.__is_importing__ = False
                except KeyboardInterrupt:
                    pass
                except SystemExit:
                    pass
                except Exception as e:
                    
                    report_error('SciKit-Learn', traceback.format_exc(), e)
                    raise
                finally:
                    self.__is_importing__ = False
            
            return mod
        return mod

# MARK: - SKImage

class SkImageImporter(object):
    """
    Meta path for importing SkImage to be added to `sys.meta_path`.
    """
    
    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        
        if fullname == 'skimage' and not self.__is_importing__:
            return self
        
        if fullname in ('skimage.filters._ctmf', 'skimage.filters.rank.bilateral_cy', 'skimage.filters.rank.generic_cy', 'skimage.filters.rank.percentile_cy', 'skimage.filters.rank.core_cy', 'skimage.restoration._denoise_cy', 'skimage.restoration._unwrap_1d', 'skimage.restoration._unwrap_2d', 'skimage.restoration._nl_means_denoising', 'skimage.restoration._unwrap_3d', 'skimage.segmentation._felzenszwalb_cy', 'skimage.segmentation._slic', 'skimage.segmentation._quickshift_cy', 'skimage.io._plugins._colormixer', 'skimage.io._plugins._histograms', 'skimage.graph._mcp', 'skimage.graph._spath', 'skimage.graph.heap', 'skimage.measure._ccomp', 'skimage.measure._pnpoly', 'skimage.measure._marching_cubes_classic_cy', 'skimage.measure._marching_cubes_lewiner_cy', 'skimage.measure._find_contours_cy', 'skimage.measure._moments_cy', 'skimage._shared.transform', 'skimage._shared.interpolation', 'skimage._shared.geometry', 'skimage.morphology._extrema_cy', 'skimage.morphology._skeletonize_3d_cy', 'skimage.morphology._convex_hull', 'skimage.morphology._greyreconstruct', 'skimage.morphology._skeletonize_cy', 'skimage.morphology._watershed', 'skimage.feature._texture', 'skimage.feature.orb_cy', 'skimage.feature._hoghistogram', 'skimage.feature.brief_cy', 'skimage.feature.censure_cy', 'skimage.feature._haar', 'skimage.feature._hessian_det_appx', 'skimage.feature.corner_cy', 'skimage.external.tifffile._tifffile', 'skimage.transform._warps_cy', 'skimage.transform._hough_transform', 'skimage.transform._radon_transform', 'skimage.transform._seam_carving', 'skimage.draw._draw', 'skimage.future.graph._ncut_cy', 'skimage.filters._multiotsu', 'skimage.morphology._flood_fill_cy', 'skimage.morphology._max_tree', 'skimage.feature._cascade'):
            return self
        
        return
    
    def load_module(self, fullname):
    
        c.init_skimage()
        update_mods()
    
        f = fullname
        if f != 'skimage':
            f = '__' + fullname.replace('.', '_')
        mod = sys.modules.get(f)
        if mod is None:
            def importMod():
                with warnings.catch_warnings(record=True) as w:
                    mod = importlib.__import__(f)
                    sys.modules[fullname] = mod
            
            if fullname != 'skimage' or "widget" in os.environ:
                importMod()
            else:
                try:
                    self.__is_importing__ = True
                    importMod()
                    self.__is_importing__ = False
                except KeyboardInterrupt:
                    return
                except SystemExit:
                    return
                except Exception as e:
                    
                    report_error('SciKit-Image', traceback.format_exc(), e)
                    raise
                finally:
                    self.__is_importing__ = False
            
            return mod
        return mod

# MARK: - Pywt

class PywtImporter(object):
    """
    Meta path for importing Pywt to be added to `sys.meta_path`.
    """
    
    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        
        if fullname == 'pywt' and not self.__is_importing__:
            return self
        
        if fullname in ('pywt._extensions._cwt', 'pywt._extensions._dwt', 'pywt._extensions._swt', 'pywt._extensions._pywt'):
            return self
        
        return
    
    def load_module(self, fullname):
    
        c.init_pywt()
        update_mods()
    
        f = fullname
        if f != 'pywt':
            f = '__' + fullname.replace('.', '_')
        mod = sys.modules.get(f)
        if mod is None:
            def importMod():
                with warnings.catch_warnings(record=True) as w:
                    mod = importlib.__import__(f)
                    sys.modules[fullname] = mod
            
            if fullname != 'pywt' or "widget" in os.environ:
                importMod()
            else:
                try:
                    self.__is_importing__ = True
                    importMod()
                    self.__is_importing__ = False
                except KeyboardInterrupt:
                    return
                except SystemExit:
                    return
                except Exception as e:
                    
                    report_error('Pywt', traceback.format_exc(), e)
                    raise
                finally:
                    self.__is_importing__ = False
            
            return mod
        return mod

# MARK: - Nacl

class NaclImporter(object):
    """
    Meta path for importing Nacl to be added to `sys.meta_path`.
    """
    
    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        
        if fullname == 'nacl' and not self.__is_importing__:
            return self
        
        if fullname in ('nacl._sodium', 'nacl._sodium'):
            return self
        
        return
    
    def load_module(self, fullname):
    
        c.init_nacl()
        update_mods()
    
        f = fullname
        if f != 'nacl':
            f = '__' + fullname.replace('.', '_')
        mod = sys.modules.get(f)
        if mod is None:
            def importMod():
                with warnings.catch_warnings(record=True) as w:
                    mod = importlib.__import__(f)
                    sys.modules[fullname] = mod
            
            if fullname != 'nacl' or "widget" in os.environ:
                importMod()
            else:
                try:
                    self.__is_importing__ = True
                    importMod()
                    self.__is_importing__ = False
                except KeyboardInterrupt:
                    return
                except SystemExit:
                    return
                except Exception as e:
                    
                    report_error('PyNaCl', traceback.format_exc(), e)
                    raise
                finally:
                    self.__is_importing__ = False
            
            return mod
        return mod

# MARK: - Cryptography

class CryptographyImporter(object):
    """
    Meta path for importing Cryptography to be added to `sys.meta_path`.
    """
    
    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        
        if fullname == 'cryptography' and not self.__is_importing__:
            return self
        
        if fullname in ('cryptography.hazmat.bindings._constant_time', 'cryptography.hazmat.bindings._padding', 'cryptography.hazmat.bindings._openssl'):
            return self
        
        return
    
    def load_module(self, fullname):
    
        c.init_cffi()
        update_mods()
    
        f = fullname
        if f != 'cryptography':
            f = '__' + fullname.replace('.', '_')
        mod = sys.modules.get(f)
        if mod is None:
            def importMod():
                with warnings.catch_warnings(record=True) as w:
                    mod = importlib.__import__(f)
                    sys.modules[fullname] = mod
            
            if fullname != 'cryptography' or "widget" in os.environ:
                importMod()
            else:
                try:
                    self.__is_importing__ = True
                    importMod()
                    self.__is_importing__ = False
                except KeyboardInterrupt:
                    return
                except SystemExit:
                    return
                except Exception as e:
                    
                    report_error('Cryptography', traceback.format_exc(), e)
                    raise
                finally:
                    self.__is_importing__ = False
            
            return mod
        return mod

# MARK: - Bcrypt

class BcryptImporter(object):
    """
    Meta path for importing Bcrypt to be added to `sys.meta_path`.
    """
    
    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        
        if fullname == 'bcrypt' and not self.__is_importing__:
            return self
        
        if fullname in ('bcrypt._bcrypt', 'bcrypt._bcrypt'):
            return self
        
        return
    
    def load_module(self, fullname):
    
        c.init_bcrypt()
        update_mods()
    
        f = fullname
        if f != 'bcrypt':
            f = '__' + fullname.replace('.', '_')
        mod = sys.modules.get(f)
        if mod is None:
            def importMod():
                with warnings.catch_warnings(record=True) as w:
                    mod = importlib.__import__(f)
                    sys.modules[fullname] = mod
            
            if fullname != 'bcrypt' or "widget" in os.environ:
                importMod()
            else:
                try:
                    self.__is_importing__ = True
                    importMod()
                    self.__is_importing__ = False
                except KeyboardInterrupt:
                    return
                except SystemExit:
                    return
                except Exception as e:
                    
                    report_error('Bcrypt', traceback.format_exc(), e)
                    raise
                finally:
                    self.__is_importing__ = False
            
            return mod
        return mod

# MARK: - Statsmodels

class StatsmodelsImporter(object):
    """
    Meta path for importing Statsmodels to be added to `sys.meta_path`.
    """
    
    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        
        if fullname == 'statsmodels' and not self.__is_importing__:
            return self
        
        if fullname in ('statsmodels.tsa.statespace._smoothers._alternative', 'statsmodels.tsa.innovations._arma_innovations', 'statsmodels.tsa.statespace._smoothers._classical', 'statsmodels.tsa._exponential_smoothers', 'statsmodels.tsa.statespace._filters._conventional', 'statsmodels.tsa.statespace._filters._univariate_diffuse', 'statsmodels.tsa.statespace._filters._univariate', 'statsmodels.tsa.regime_switching._hamilton_filter', 'statsmodels.tsa.statespace._initialization', 'statsmodels.tsa._innovations', 'statsmodels.tsa.statespace._filters._inversions', 'statsmodels.tsa.statespace._kalman_filter', 'statsmodels.tsa.statespace._kalman_smoother', 'statsmodels.tsa.regime_switching._kim_smoother', 'statsmodels.tsa.statespace._representation', 'statsmodels.tsa.statespace._simulation_smoother', 'statsmodels.tsa.statespace._smoothers._conventional', 'statsmodels.tsa.statespace._smoothers._univariate_diffuse', 'statsmodels.tsa.statespace._smoothers._univariate', 'statsmodels.nonparametric._smoothers_lowess', 'statsmodels.tsa._stl', 'statsmodels.tsa.statespace._tools', 'statsmodels.tsa.kalmanf.kalman_loglike', 'statsmodels.nonparametric.linbin',):
            return self
        
        return
    
    def load_module(self, fullname):
    
        c.init_statsmodels()
        update_mods()
    
        f = fullname
        if f != 'statsmodels':
            f = '__' + fullname.replace('.', '_')
            
        mod = sys.modules.get(f)
        if mod is None:
            def importMod():
                with warnings.catch_warnings(record=True) as w:
                    mod = importlib.__import__(f)
                    sys.modules[fullname] = mod
            
            if fullname != 'statsmodels' or "widget" in os.environ:
                importMod()
            else:
                try:
                    self.__is_importing__ = True
                    importMod()
                    self.__is_importing__ = False
                except KeyboardInterrupt:
                    return
                except SystemExit:
                    return
                except Exception as e:
                    
                    report_error('Statsmodels', traceback.format_exc(), e)
                    raise
                finally:
                    self.__is_importing__ = False
            
            return mod
        return mod

# MARK: - Zmq

class ZmqImporter(object):
    """
    Meta path for importing Zmq to be added to `sys.meta_path`.
    """
    
    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        
        if fullname == 'zmq' and not self.__is_importing__:
            return self
        
        if fullname in ('zmq.backend.cython._device', 'zmq.backend.cython._poll', 'zmq.backend.cython._proxy_steerable', 'zmq.backend.cython._version', 'zmq.backend.cython.constants', 'zmq.backend.cython.context', 'zmq.backend.cython.error', 'zmq.backend.cython.message', 'zmq.devices.monitoredqueue', 'zmq.backend.cython.socket', 'zmq.backend.cython.utils'):
            return self
        
        return
    
    def load_module(self, fullname):
    
        c.init_zmq()
        update_mods()
    
        f = fullname
        if f != 'zmq':
            f = '__' + fullname.replace('.', '_')
        mod = sys.modules.get(f)
        if mod is None:
            def importMod():
                with warnings.catch_warnings(record=True) as w:
                    mod = importlib.__import__(f)
                    sys.modules[fullname] = mod
            
            if fullname != 'zmq' or "widget" in os.environ:
                importMod()
            else:
                try:
                    self.__is_importing__ = True
                    importMod()
                    self.__is_importing__ = False
                except KeyboardInterrupt:
                    return
                except SystemExit:
                    return
                except Exception as e:
                    
                    report_error('Zmq', traceback.format_exc(), e)
                    raise
                finally:
                    self.__is_importing__ = False
            
            return mod
        return mod

# MARK: - Regex

class RegexImporter(object):
    """
    Meta path for importing Regex to be added to `sys.meta_path`.
    """
    
    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        
        if fullname == 'regex' and not self.__is_importing__:
            return self
        
        if fullname == 'regex._regex':
            return self
        
        return
    
    def load_module(self, fullname):
    
        c.init_regex()
        update_mods()
    
        f = fullname
        if f != 'regex':
            f = '__' + fullname.replace('.', '_')
        mod = sys.modules.get(f)
        if mod is None:
            def importMod():
                with warnings.catch_warnings(record=True) as w:
                    mod = importlib.__import__(f)
                    sys.modules[fullname] = mod
            
            if fullname != 'regex' or "widget" in os.environ:
                importMod()
            else:
                try:
                    self.__is_importing__ = True
                    importMod()
                    self.__is_importing__ = False
                except KeyboardInterrupt:
                    return
                except SystemExit:
                    return
                except Exception as e:
                    
                    report_error('Regex', traceback.format_exc(), e)
                    raise
                finally:
                    self.__is_importing__ = False
            
            return mod
        return mod

# MARK: - Gensim

class GensimImporter(object):
    """
    Meta path for importing Gensim to be added to `sys.meta_path`.
    """
    
    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        
        if fullname == 'gensim' and not self.__is_importing__:
            return self
        
        if fullname in ('gensim._matutils', 'gensim.corpora._mmreader', 'gensim.models._utils_any2vec', 'gensim.models.doc2vec_corpusfile', 'gensim.models.doc2vec_inner', 'gensim.models.fasttext_corpusfile', 'gensim.models.fasttext_inner', 'gensim.models.nmf_pgd', 'gensim.models.word2vec_corpusfile', 'gensim.models.word2vec_inner'):
            return self
        
        return
    
    def load_module(self, fullname):
    
        c.init_gensim()
        update_mods()
    
        f = fullname
        if f != 'gensim':
            f = '__' + fullname.replace('.', '_')
        mod = sys.modules.get(f)
        if mod is None:
            def importMod():
                with warnings.catch_warnings(record=True) as w:
                    mod = importlib.__import__(f)
                    sys.modules[fullname] = mod
            
            if fullname != 'gensim' or "widget" in os.environ:
                importMod()
            else:
                try:
                    self.__is_importing__ = True
                    importMod()
                    self.__is_importing__ = False
                except KeyboardInterrupt:
                    return
                except SystemExit:
                    return
                except Exception as e:
                    
                    report_error('Gensim', traceback.format_exc(), e)
                    raise
                finally:
                    self.__is_importing__ = False
            
            return mod
        return mod

# MARK: - Downloadable Content

class DownloadableImporter(object):
    """
    Meta path for importing downloadable libraries to be added to `sys.meta_path`.
    """
    
    __is_importing__ = False
    
    def find_module(self, fullname, mpath=None):
        
        if self.__is_importing__:
            return
        
        libname = fullname.split(".")[0]
        if libname in ('imageio', 'networkx', 'dask', 'jmespath', 'joblib', 'smart_open', 'boto', 'boto3', 'botocore', 'pywt', 'bcrypt', 'Bio', 'cryptography',  'cv2', 'gensim', 'lxml', 'matplotlib', 'nacl', 'numpy', 'pandas', 'regex', 'scipy', 'skimage', 'sklearn', 'statsmodels', 'zmq'):
            return self
        
        return
    
    def load_module(self, fullname):
        self.__is_importing__ = True
        
        try:
            mod = importlib.__import__(fullname)
            self.__is_importing__ = False
            return mod
        except ModuleNotFoundError:
        
            if not have_internet():
                msg = f"The internet connection seems to be offline and the imported library {fullname.split('.')[0].lower()} is not downloaded. Make sure you are connected to internet. Once downloaded, the library will be available offline."
                raise ImportError(msg)
        
            paths = Python.shared.access(fullname.split(".")[0].lower())
            for path in paths:
                if str(path) == "error":
                    self.__is_importing__ = False
                    raise ImportError(str(paths[1]))
                if not str(path) in sys.path:
                    sys.path.insert(0, str(path))
            
            try:
                return importlib.__import__(fullname)
            finally:
                self.__is_importing__ = False
        
        self.__is_importing__ = False

# MARK: - All

__all__ = ['DownloadableImporter', 'NumpyImporter', 'MatplotlibImporter', 'PandasImporter', 'PillowImporter', 'BiopythonImporter', 'LXMLImporter', 'ScipyImporter', 'SkLearnImporter', 'SkImageImporter', 'PywtImporter', 'NaclImporter', 'CryptographyImporter', 'BcryptImporter', 'StatsmodelsImporter', 'ZmqImporter', 'RegexImporter', 'GensimImporter']
